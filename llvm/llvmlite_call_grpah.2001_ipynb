{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5be3cac8",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "papermill": {
     "duration": 0.003027,
     "end_time": "2026-02-19T11:23:40.274958",
     "exception": false,
     "start_time": "2026-02-19T11:23:40.271931",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# More complex call graph example with llvmlite:\n",
    "- direct calls\n",
    "- extern calls\n",
    "- recursion & mutual recursion\n",
    "- indirect calls via function pointers\n",
    "- simple resolution from a global function table\n",
    "\n",
    "Output: adjacency + DOT + edge call counts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ac19597a",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2026-02-19T11:23:40.280408Z",
     "iopub.status.busy": "2026-02-19T11:23:40.280043Z",
     "iopub.status.idle": "2026-02-19T11:23:40.346998Z",
     "shell.execute_reply": "2026-02-19T11:23:40.346129Z"
    },
    "papermill": {
     "duration": 0.072655,
     "end_time": "2026-02-19T11:23:40.349533",
     "exception": false,
     "start_time": "2026-02-19T11:23:40.276878",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from llvmlite import ir\n",
    "from collections import defaultdict, Counter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "a1fd0396",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2026-02-19T11:23:40.355491Z",
     "iopub.status.busy": "2026-02-19T11:23:40.355180Z",
     "iopub.status.idle": "2026-02-19T11:23:40.378003Z",
     "shell.execute_reply": "2026-02-19T11:23:40.377118Z"
    },
    "papermill": {
     "duration": 0.028975,
     "end_time": "2026-02-19T11:23:40.380654",
     "exception": false,
     "start_time": "2026-02-19T11:23:40.351679",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== LLVM IR (complex) ===\n",
      "; ModuleID = \"cg_complex\"\n",
      "target triple = \"unknown-unknown-unknown\"\n",
      "target datalayout = \"\"\n",
      "\n",
      "declare i32 @\"puts\"(i8* %\".1\")\n",
      "\n",
      "@\"msg_even\" = internal constant [5 x i8] c\"even\\00\", align 1\n",
      "@\"msg_odd\" = internal constant [4 x i8] c\"odd\\00\", align 1\n",
      "define i32 @\"leafA\"(i32 %\".1\")\n",
      "{\n",
      "entry:\n",
      "  %\".3\" = add i32 %\".1\", 7\n",
      "  ret i32 %\".3\"\n",
      "}\n",
      "\n",
      "define i32 @\"leafB\"(i32 %\".1\")\n",
      "{\n",
      "entry:\n",
      "  %\".3\" = mul i32 %\".1\", 3\n",
      "  ret i32 %\".3\"\n",
      "}\n",
      "\n",
      "define i32 @\"is_even\"(i32 %\".1\")\n",
      "{\n",
      "entry:\n",
      "  %\".3\" = icmp eq i32 %\".1\", 0\n",
      "  br i1 %\".3\", label %\"exit\", label %\"recurse\"\n",
      "recurse:\n",
      "  %\".6\" = sub i32 %\".1\", 1\n",
      "  %\".7\" = call i32 @\"is_odd\"(i32 %\".6\")\n",
      "  ret i32 %\".7\"\n",
      "exit:\n",
      "  ret i32 1\n",
      "}\n",
      "\n",
      "define i32 @\"is_odd\"(i32 %\".1\")\n",
      "{\n",
      "entry:\n",
      "  %\".3\" = icmp eq i32 %\".1\", 0\n",
      "  br i1 %\".3\", label %\"exit\", label %\"recurse\"\n",
      "recurse:\n",
      "  %\".6\" = sub i32 %\".1\", 1\n",
      "  %\".7\" = call i32 @\"is_even\"(i32 %\".6\")\n",
      "  ret i32 %\".7\"\n",
      "exit:\n",
      "  ret i32 0\n",
      "}\n",
      "\n",
      "define i32 @\"parity_print\"(i32 %\".1\")\n",
      "{\n",
      "entry:\n",
      "  %\"ev\" = call i32 @\"is_even\"(i32 %\".1\")\n",
      "  %\".3\" = icmp ne i32 %\"ev\", 0\n",
      "  br i1 %\".3\", label %\"then\", label %\"else\"\n",
      "then:\n",
      "  %\".5\" = call i32 @\"puts\"(i8* getelementptr ([5 x i8], [5 x i8]* @\"msg_even\", i32 0, i32 0))\n",
      "  br label %\"exit\"\n",
      "else:\n",
      "  %\".7\" = call i32 @\"puts\"(i8* getelementptr ([4 x i8], [4 x i8]* @\"msg_odd\", i32 0, i32 0))\n",
      "  br label %\"exit\"\n",
      "exit:\n",
      "  ret i32 %\".1\"\n",
      "}\n",
      "\n",
      "@\"fn_table\" = internal global [2 x i32 (i32)*] [i32 (i32)* @\"leafA\", i32 (i32)* @\"leafB\"]\n",
      "define i32 @\"dispatch\"(i32 %\".1\", i32 %\".2\")\n",
      "{\n",
      "entry:\n",
      "  %\"idx\" = and i32 %\".1\", 1\n",
      "  %\"slot_ptr\" = getelementptr inbounds [2 x i32 (i32)*], [2 x i32 (i32)*]* @\"fn_table\", i32 0, i32 %\"idx\"\n",
      "  %\"fn_ptr\" = load i32 (i32)*, i32 (i32)** %\"slot_ptr\"\n",
      "  %\"res\" = call i32 %\"fn_ptr\"(i32 %\".2\")\n",
      "  ret i32 %\"res\"\n",
      "}\n",
      "\n",
      "define i32 @\"main\"()\n",
      "{\n",
      "entry:\n",
      "  %\".2\" = call i32 @\"parity_print\"(i32 7)\n",
      "  %\".3\" = call i32 @\"dispatch\"(i32 1, i32 10)\n",
      "  %\".4\" = call i32 @\"dispatch\"(i32 0, i32 10)\n",
      "  %\".5\" = add i32 %\".3\", %\".4\"\n",
      "  ret i32 %\".5\"\n",
      "}\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Build a more complex module\n",
    "\n",
    "m = ir.Module(name=\"cg_complex\")\n",
    "i32 = ir.IntType(32)\n",
    "i8  = ir.IntType(8)\n",
    "i8p = i8.as_pointer()\n",
    "\n",
    "# extern int puts(char*);\n",
    "puts = ir.Function(m, ir.FunctionType(i32, [i8p]), name=\"puts\")\n",
    "\n",
    "# helper to create a global string constant\n",
    "def add_global_cstr(module, name, s: bytes):\n",
    "    arr_ty = ir.ArrayType(i8, len(s))\n",
    "    gv = ir.GlobalVariable(module, arr_ty, name=name)\n",
    "    gv.linkage = \"internal\"\n",
    "    gv.global_constant = True\n",
    "    gv.initializer = ir.Constant(arr_ty, bytearray(s))\n",
    "    gv.align = 1\n",
    "    # i8* pointer to first element\n",
    "    zero = ir.Constant(i32, 0)\n",
    "    return gv.gep((zero, zero))\n",
    "\n",
    "msg_even = add_global_cstr(m, \"msg_even\", b\"even\\0\")\n",
    "msg_odd  = add_global_cstr(m, \"msg_odd\",  b\"odd\\0\")\n",
    "\n",
    "# int leafA(int x) { return x + 7; }\n",
    "leafA = ir.Function(m, ir.FunctionType(i32, [i32]), name=\"leafA\")\n",
    "x = leafA.args[0]\n",
    "b = ir.IRBuilder(leafA.append_basic_block(\"entry\"))\n",
    "b.ret(b.add(x, ir.Constant(i32, 7)))\n",
    "\n",
    "# int leafB(int x) { return x * 3; }\n",
    "leafB = ir.Function(m, ir.FunctionType(i32, [i32]), name=\"leafB\")\n",
    "x = leafB.args[0]\n",
    "b = ir.IRBuilder(leafB.append_basic_block(\"entry\"))\n",
    "b.ret(b.mul(x, ir.Constant(i32, 3)))\n",
    "\n",
    "# Mutual recursion:\n",
    "# int is_even(int n) { if (n==0) return 1; return is_odd(n-1); }\n",
    "# int is_odd(int n)  { if (n==0) return 0; return is_even(n-1); }\n",
    "is_even = ir.Function(m, ir.FunctionType(i32, [i32]), name=\"is_even\")\n",
    "is_odd  = ir.Function(m, ir.FunctionType(i32, [i32]), name=\"is_odd\")\n",
    "\n",
    "def build_even_odd(fn, other_fn, base_ret):\n",
    "    n = fn.args[0]\n",
    "    entry = fn.append_basic_block(\"entry\")\n",
    "    rec   = fn.append_basic_block(\"recurse\")\n",
    "    exitb = fn.append_basic_block(\"exit\")\n",
    "    b = ir.IRBuilder(entry)\n",
    "    cond = b.icmp_signed(\"==\", n, ir.Constant(i32, 0))\n",
    "    b.cbranch(cond, exitb, rec)\n",
    "\n",
    "    b.position_at_end(exitb)\n",
    "    b.ret(ir.Constant(i32, base_ret))\n",
    "\n",
    "    b.position_at_end(rec)\n",
    "    n1 = b.sub(n, ir.Constant(i32, 1))\n",
    "    r = b.call(other_fn, [n1])\n",
    "    b.ret(r)\n",
    "\n",
    "build_even_odd(is_even, is_odd, 1)\n",
    "build_even_odd(is_odd,  is_even, 0)\n",
    "\n",
    "# A function that calls extern puts and calls recursion functions\n",
    "# int parity_print(int n) {\n",
    "#   if (is_even(n)) puts(\"even\"); else puts(\"odd\");\n",
    "#   return n;\n",
    "# }\n",
    "parity_print = ir.Function(m, ir.FunctionType(i32, [i32]), name=\"parity_print\")\n",
    "n = parity_print.args[0]\n",
    "entry = parity_print.append_basic_block(\"entry\")\n",
    "thenb = parity_print.append_basic_block(\"then\")\n",
    "elseb = parity_print.append_basic_block(\"else\")\n",
    "exitb = parity_print.append_basic_block(\"exit\")\n",
    "b = ir.IRBuilder(entry)\n",
    "\n",
    "ev = b.call(is_even, [n], name=\"ev\")\n",
    "cond = b.icmp_signed(\"!=\", ev, ir.Constant(i32, 0))\n",
    "b.cbranch(cond, thenb, elseb)\n",
    "\n",
    "b.position_at_end(thenb)\n",
    "b.call(puts, [msg_even])\n",
    "b.branch(exitb)\n",
    "\n",
    "b.position_at_end(elseb)\n",
    "b.call(puts, [msg_odd])\n",
    "b.branch(exitb)\n",
    "\n",
    "b.position_at_end(exitb)\n",
    "b.ret(n)\n",
    "\n",
    "# --- Function pointers / indirect calls ---\n",
    "# We'll create a global function table: [2 x (i32 (i32)*)] = { leafA, leafB }\n",
    "fnptr_ty = ir.FunctionType(i32, [i32]).as_pointer()\n",
    "table_ty = ir.ArrayType(fnptr_ty, 2)\n",
    "\n",
    "fn_table = ir.GlobalVariable(m, table_ty, name=\"fn_table\")\n",
    "fn_table.linkage = \"internal\"\n",
    "fn_table.initializer = ir.Constant(table_ty, [leafA, leafB])\n",
    "\n",
    "# int dispatch(int which, int x) {\n",
    "#   fn = fn_table[which & 1];   // pick leafA or leafB\n",
    "#   return fn(x);              // indirect call\n",
    "# }\n",
    "dispatch = ir.Function(m, ir.FunctionType(i32, [i32, i32]), name=\"dispatch\")\n",
    "which, x = dispatch.args\n",
    "entry = dispatch.append_basic_block(\"entry\")\n",
    "b = ir.IRBuilder(entry)\n",
    "\n",
    "idx = b.and_(which, ir.Constant(i32, 1), name=\"idx\")\n",
    "zero = ir.Constant(i32, 0)\n",
    "slot_ptr = b.gep(fn_table, [zero, idx], inbounds=True, name=\"slot_ptr\")\n",
    "fn_ptr = b.load(slot_ptr, name=\"fn_ptr\")\n",
    "\n",
    "# Indirect call (callee is a value, not an ir.Function)\n",
    "res = b.call(fn_ptr, [x], name=\"res\")\n",
    "b.ret(res)\n",
    "\n",
    "# int main() { parity_print(7); return dispatch(1, 10) + dispatch(0, 10); }\n",
    "main = ir.Function(m, ir.FunctionType(i32, []), name=\"main\")\n",
    "b = ir.IRBuilder(main.append_basic_block(\"entry\"))\n",
    "b.call(parity_print, [ir.Constant(i32, 7)])\n",
    "r1 = b.call(dispatch, [ir.Constant(i32, 1), ir.Constant(i32, 10)])\n",
    "r2 = b.call(dispatch, [ir.Constant(i32, 0), ir.Constant(i32, 10)])\n",
    "b.ret(b.add(r1, r2))\n",
    "\n",
    "print(\"=== LLVM IR (complex) ===\")\n",
    "print(m)\n",
    "\n",
    "# "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "4454603f",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2026-02-19T11:23:40.386494Z",
     "iopub.status.busy": "2026-02-19T11:23:40.386205Z",
     "iopub.status.idle": "2026-02-19T11:23:40.402599Z",
     "shell.execute_reply": "2026-02-19T11:23:40.401138Z"
    },
    "papermill": {
     "duration": 0.022214,
     "end_time": "2026-02-19T11:23:40.404972",
     "exception": false,
     "start_time": "2026-02-19T11:23:40.382758",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Resolved function tables: {}\n",
      "\n",
      "=== Call graph (adjacency) ===\n",
      "leafA        -> []\n",
      "leafB        -> []\n",
      "is_even      -> ['is_odd']\n",
      "is_odd       -> ['is_even']\n",
      "parity_print -> ['is_even', 'puts']\n",
      "dispatch     -> ['<indirect>']\n",
      "main         -> ['dispatch', 'parity_print']\n",
      "\n",
      "=== Edge call-site counts (direct call sites) ===\n",
      "parity_print -> puts          callsites=2\n",
      "main         -> dispatch      callsites=2\n",
      "is_even      -> is_odd        callsites=1\n",
      "is_odd       -> is_even       callsites=1\n",
      "parity_print -> is_even       callsites=1\n",
      "dispatch     -> <indirect>    callsites=1\n",
      "main         -> parity_print  callsites=1\n",
      "\n",
      "=== Indirect call sites (raw IR call instructions) ===\n",
      "dispatch: %\"res\" = call i32 %\"fn_ptr\"(i32 %\".2\")\n"
     ]
    }
   ],
   "source": [
    "# Call graph extraction + simple indirect resolution\n",
    "\n",
    "def resolve_fnptr_from_global_table(module: ir.Module):\n",
    "    \"\"\"\n",
    "    Very small resolver for the specific pattern:\n",
    "    global array of function pointers initialized with function symbols.\n",
    "    Returns mapping: global_name -> list(function_names)\n",
    "    \"\"\"\n",
    "    tables = {}\n",
    "    for gv in module.global_values:\n",
    "        if isinstance(gv, ir.GlobalVariable) and gv.initializer is not None:\n",
    "            init = gv.initializer\n",
    "            # Detect an array initializer that contains functions\n",
    "            if isinstance(init.type, ir.ArrayType):\n",
    "                elems = []\n",
    "                try:\n",
    "                    for op in init.operands:\n",
    "                        if isinstance(op, ir.Function):\n",
    "                            elems.append(op.name)\n",
    "                except Exception:\n",
    "                    pass\n",
    "                if elems:\n",
    "                    tables[gv.name] = elems\n",
    "    return tables\n",
    "\n",
    "tables = resolve_fnptr_from_global_table(m)\n",
    "print(\"\\nResolved function tables:\", tables)\n",
    "\n",
    "def build_call_graph(module: ir.Module, include_extern=True):\n",
    "    \"\"\"\n",
    "    Returns:\n",
    "      cg: caller -> set(callees)\n",
    "      edge_counts: (caller, callee) -> number_of_call_sites\n",
    "      indirect_sites: list of (caller, detail_string)\n",
    "    \"\"\"\n",
    "    cg = defaultdict(set)\n",
    "    edge_counts = Counter()\n",
    "    indirect_sites = []\n",
    "\n",
    "    for fn in module.functions:\n",
    "        if fn.is_declaration:\n",
    "            continue\n",
    "        caller = fn.name\n",
    "\n",
    "        for block in fn.blocks:\n",
    "            for instr in block.instructions:\n",
    "                if instr.opname == \"call\":\n",
    "                    callee = getattr(instr, \"callee\", None)\n",
    "\n",
    "                    # Direct call\n",
    "                    if isinstance(callee, ir.Function):\n",
    "                        if include_extern or (not callee.is_declaration):\n",
    "                            cg[caller].add(callee.name)\n",
    "                            edge_counts[(caller, callee.name)] += 1\n",
    "                        continue\n",
    "\n",
    "                    # Indirect call: attempt to resolve known pattern (load from fn_table)\n",
    "                    # We'll mark it and also (optionally) add possible edges.\n",
    "                    cg[caller].add(\"<indirect>\")\n",
    "                    edge_counts[(caller, \"<indirect>\")] += 1\n",
    "\n",
    "                    # naive pattern print\n",
    "                    indirect_sites.append((caller, str(instr)))\n",
    "\n",
    "                    # OPTIONAL: if you know this module has a global fn_table,\n",
    "                    # you can conservatively add edges to all possible targets.\n",
    "                    # (This is common in call-graph building: over-approximation.)\n",
    "                    for tbl_name, targets in tables.items():\n",
    "                        # If the IR text mentions @fn_table, assume it might be this table.\n",
    "                        if f\"@{tbl_name}\" in str(fn):\n",
    "                            for t in targets:\n",
    "                                cg[caller].add(t)\n",
    "                                edge_counts[(caller, t)] += 0  # \"possible\" edge, not a direct call site\n",
    "\n",
    "        cg[caller] |= set()\n",
    "\n",
    "    # Add extern-only nodes if included\n",
    "    if include_extern:\n",
    "        for fn in module.functions:\n",
    "            if fn.is_declaration:\n",
    "                # include as node if it is called\n",
    "                pass\n",
    "\n",
    "    return dict(cg), edge_counts, indirect_sites\n",
    "\n",
    "cg, edge_counts, indirect_sites = build_call_graph(m, include_extern=True)\n",
    "\n",
    "print(\"\\n=== Call graph (adjacency) ===\")\n",
    "for caller, callees in cg.items():\n",
    "    print(f\"{caller:12s} -> {sorted(callees)}\")\n",
    "\n",
    "print(\"\\n=== Edge call-site counts (direct call sites) ===\")\n",
    "for (caller, callee), cnt in edge_counts.most_common(20):\n",
    "    print(f\"{caller:12s} -> {callee:12s}  callsites={cnt}\")\n",
    "\n",
    "print(\"\\n=== Indirect call sites (raw IR call instructions) ===\")\n",
    "for caller, s in indirect_sites[:10]:\n",
    "    print(f\"{caller}: {s}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "8d21fcb3",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2026-02-19T11:23:40.411399Z",
     "iopub.status.busy": "2026-02-19T11:23:40.410831Z",
     "iopub.status.idle": "2026-02-19T11:23:40.419229Z",
     "shell.execute_reply": "2026-02-19T11:23:40.418263Z"
    },
    "papermill": {
     "duration": 0.013873,
     "end_time": "2026-02-19T11:23:40.421238",
     "exception": false,
     "start_time": "2026-02-19T11:23:40.407365",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "=== Graphviz DOT ===\n",
      "digraph CallGraph {\n",
      "  rankdir=LR;\n",
      "  \"<indirect>\" [shape=diamond, style=filled, fillcolor=lightgray];\n",
      "  \"dispatch\" [shape=box];\n",
      "  \"is_even\" [shape=box];\n",
      "  \"is_odd\" [shape=box];\n",
      "  \"leafA\" [shape=box];\n",
      "  \"leafB\" [shape=box];\n",
      "  \"main\" [shape=box, style=filled, fillcolor=lightblue];\n",
      "  \"parity_print\" [shape=box];\n",
      "  \"puts\" [shape=box];\n",
      "  \"is_even\" -> \"is_odd\" [label=\"1\"];\n",
      "  \"is_odd\" -> \"is_even\" [label=\"1\"];\n",
      "  \"parity_print\" -> \"is_even\" [label=\"1\"];\n",
      "  \"parity_print\" -> \"puts\" [label=\"2\"];\n",
      "  \"dispatch\" -> \"<indirect>\" [label=\"1\"];\n",
      "  \"main\" -> \"dispatch\" [label=\"2\"];\n",
      "  \"main\" -> \"parity_print\" [label=\"1\"];\n",
      "}\n"
     ]
    }
   ],
   "source": [
    "# DOT output (Graphviz)\n",
    "\n",
    "def callgraph_to_dot(cg: dict, edge_counts: Counter):\n",
    "    nodes = set(cg.keys())\n",
    "    for callees in cg.values():\n",
    "        nodes.update(callees)\n",
    "\n",
    "    lines = [\"digraph CallGraph {\", \"  rankdir=LR;\"]\n",
    "\n",
    "    for n in sorted(nodes):\n",
    "        if n == \"<indirect>\":\n",
    "            lines.append(f'  \"{n}\" [shape=diamond, style=filled, fillcolor=lightgray];')\n",
    "        elif n == \"main\":\n",
    "            lines.append(f'  \"{n}\" [shape=box, style=filled, fillcolor=lightblue];')\n",
    "        else:\n",
    "            lines.append(f'  \"{n}\" [shape=box];')\n",
    "\n",
    "    for caller, callees in cg.items():\n",
    "        for callee in callees:\n",
    "            cnt = edge_counts.get((caller, callee), None)\n",
    "            # label only if we have a call-site count\n",
    "            if cnt is not None and cnt > 0:\n",
    "                lines.append(f'  \"{caller}\" -> \"{callee}\" [label=\"{cnt}\"];')\n",
    "            else:\n",
    "                lines.append(f'  \"{caller}\" -> \"{callee}\";')\n",
    "\n",
    "    lines.append(\"}\")\n",
    "    return \"\\n\".join(lines)\n",
    "\n",
    "dot = callgraph_to_dot(cg, edge_counts)\n",
    "print(\"\\n=== Graphviz DOT ===\")\n",
    "print(dot)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "073bab5b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-19T11:23:40.427999Z",
     "iopub.status.busy": "2026-02-19T11:23:40.427226Z",
     "iopub.status.idle": "2026-02-19T11:23:40.766989Z",
     "shell.execute_reply": "2026-02-19T11:23:40.766015Z"
    },
    "papermill": {
     "duration": 0.345696,
     "end_time": "2026-02-19T11:23:40.769248",
     "exception": false,
     "start_time": "2026-02-19T11:23:40.423552",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAmcAAAE3CAYAAADv1OZ7AABRRElEQVR4Ae2dCdxV0/7/v00SFRKVhOQaIkPFJZEkQ6qLUpSp/6VLhnRFUVfhmjJkuFwXSeYiopukjBHdZkOiDGlCpaJROP/9Wfe3zz3Pec45z3meM+5z3qvX6Tln77XXXuu99jn7s7/ru76rUshLRoIABCAAAQhAAAIQyAcCEyvnQy2oAwQgAAEIQAACEIDAfwkgzrgSIAABCEAAAhCAQB4RQJzlUWdQFQhAAAIQgAAEIFA1GsHSpUtt2rRp0Zv5HEWgW7duUVv4CAEIQAACEIAABFInUCl6QsCYMWOse/fuqZdc4CUwj6LAO5jmQQACEIAABHJDIP6EAIkPXqUZjB49OjddxVkhAAEIQAACECgKAvicFUU300gIQAACEIAABIJCAHEWlJ6inhCAAAQgAAEIFAUBxFlRdDONhAAEIAABCEAgKAQQZ0HpKeoJAQhAAAIQgEBREECcFUU300gIQAACEIAABIJCAHEWlJ6inhCAAAQgAAEIFAUBxFlRdDONhAAEIAABCEAgKAQQZ0HpKeoJAQhAAAIQgEBREECcFUU300gIQAACEIAABIJCAHEWlJ6inhCAAAQgAAEIFAUBxFlRdDONhAAEIAABCEAgKAQQZ0HpKeoJAQhAAAIQgEBREECcFUU300gIQAACEIAABIJCAHEWlJ6inhCAAAQgAAEIFAWBjIizO++803bddVerVKmSPfTQQ2kFuWXLFuvbt6/Vr1/ftttuO7vooots7733dufS+fxX1apVrW7dunbCCSfYiy++mNY6UBgEIAABCEAAAhDIFIGMiLP+/fvbtGnTMlLnu+66y1577TVbsGCB3XPPPXbSSSfZV199ZU2aNLEddtjBQqGQe61cudJGjx5ty5Ytsy5durj3GakQhUIAAhCAAAQgAIE0EsiIOEtj/UoVNW7cOGvZsqXtuOOO1rt3b+vatWupPNqw0047Wbt27ezee+91+8eMGRMzHxshAAEIQAACEIBAPhEInDhbunSpVatWLWmGe+21l8u7du3apI8hIwQgAAEIQAACEMgVgayKs99++82uv/5622OPPaxGjRp28MEHlxhunDp1qjVt2tQNT2677bbWrFkzmzRpkmMzefJk22effWzFihU2atQo51tWs2bNMrl99NFHLk+bNm3KzEsGCEAAAhCAAAQgkGsCWRVnAwcOtGHDhtnw4cOdyOrUqZP16NHDZs6c6Th8//331r17d/vmm29s+fLlJvHVs2dPt699+/a2aNEiq1evnp1//vnOr2z9+vVx+W3atMn5psn/7cQTT7Srrroqbl52QAACEIAABCAAgXwhkDVxtnnzZnvwwQft9NNPdw768hkbPHiwG6IcOXKk4yH/sSFDhjh/sTp16ljnzp1t9erVJuf+ZNK6devCszU1k/OUU06x2rVrO4FXnqHQZM5FHghAAAIQgAAEIJAJAlkTZ59//rlt3LjRDjrooHA7NLSpkBiaeRkr+YJKw6HJpMjZmlu3bjX5p/Xr18+uuOIKN4S6atWqZIohDwQgAAEIQAACEMgZgayJsw0bNrhGylrmxyLT38WLFzvRpp0TJkyw4447znbZZRerXr26XXPNNRUGozhnDRs2tF69epnirkkc3nrrrRUujwMhAAEIQAACEIBANghkTZxJcCnJ38yPReb//eCDD+zbb791Q56ypE2fPt00RHn77benhYEmFijNnz8/LeVRCAQgAAEIQAACEMgUgaqZKji63EaNGplmYM6dOzd6l/v88ccfm4Yi+/Tp4yL+a6Msa+lIs2bNcsXst99+6SiOMiAAAQhAAAIQgEDGCGTNciZhpiHGZ5991k0M+Omnn0y+ZPILU3gMhddQmjJlimnywMKFC50Frbwt1yzN33//3VnnNONTkw00lKqlnOR/RoIABCAAAQhAAAL5TCAj4uzuu++21q1bu3YrlIWWT1LScksSSBqu3Hnnna1BgwZ25ZVX2po1a1xMswEDBtgDDzzgtg8aNMj5n+k4lfXee+9Z8+bNTeE2nn76aWvRooWNHTvWXnrpJRf/7Msvv3RDoZqlWaVKFatcubKzwMnP7Oyzz7bZs2fbnnvuqeJIEIAABCAAAQhAIG8JVPL8vkKRtdMyR4o1FrU5MktRv4dPUXc/jYcABCAAAQhkmsDEjFjOMl1ryocABCAAAQhAAAKFSgBxVqg9S7sgAAEIQAACEAgkAcRZILuNSkMAAhCAAAQgUKgEEGeF2rO0CwIQgAAEIACBQBJAnAWy26g0BCAAAQhAAAKFSgBxVqg9S7sgAAEIQAACEAgkAcRZILuNSkMAAhCAAAQgUKgEEGeF2rO0CwIQgAAEIACBQBJAnAWy26g0BCAAAQhAAAKFSgBxVqg9S7sgAAEIQAACEAgkAcRZILuNSkMAAhCAAAQgUKgEEGeF2rO0CwIQgAAEIACBQBJAnAWy26g0BCAAAQhAAAKFSgBxVqg9S7sgAAEIQAACEAgkAcRZILuNSkMAAhCAAAQgUKgEEGeF2rO0CwIQgAAEIACBQBJAnAWy26g0BCAAAQhAAAKFSqBqvIaNGTMm3q6i3v7BBx8UdftpPAQgAAEIQAACmSUQV5x17949s2emdAhAAAIQgAAEIACBUgQqhbxUaisbIAABCEAAAhCAAARyQWAiPme5wM45IQABCEAAAhCAQBwCiLM4YNgMAQhAAAIQgAAEckEAcZYL6pwTAhCAAAQgAAEIxCGAOIsDhs0QgAAEIAABCEAgFwQQZ7mgzjkhAAEIQAACEIBAHAKIszhg2AwBCEAAAhCAAARyQQBxlgvqnBMCEIAABCAAAQjEIYA4iwOGzRCAAAQgAAEIQCAXBBBnuaDOOSEAAQhAAAIQgEAcAoizOGDYDAEIQAACEIAABHJBAHGWC+qcEwIQgAAEIAABCMQhgDiLA4bNEIAABCAAAQhAIBcEEGe5oM45IQABCEAAAhCAQBwCiLM4YNgMAQhAAAIQgAAEckEAcZYL6pwTAhCAAAQgAAEIxCGAOIsDhs0QgAAEIAABCEAgFwQQZ7mgzjkhAAEIQAACEIBAHAKIszhg2AwBCEAAAhCAAARyQQBxlgvqnBMCEIAABCAAAQjEIYA4iwOGzRCAAAQgAAEIQCAXBBBnuaDOOSEAAQhAAAIQgEAcAlWjty9dutSmTZsWvZnPUQS6desWtYWPEIAABCAAAQhAIHUClUJeiixmzJgx1r1798hNvI9BIApbjBxsggAEIAABCEAAAuUmMDHusKbEB6/SDEaPHl1uyhwAAQhAAAIQgAAEkiUQV5wlWwD5IAABCEAAAhCAAATSRwBxlj6WlAQBCEAAAhCAAARSJoA4SxkhBUAAAhCAAAQgAIH0EUCcpY8lJUEAAhCAAAQgAIGUCSDOUkZIARCAAAQgAAEIQCB9BBBn6WNJSRCAAAQgAAEIQCBlAoizlBFSAAQgAAEIQAACEEgfAcRZ+lhSEgQgAAEIQAACEEiZAOIsZYQUAAEIQAACEIAABNJHAHGWPpaUBAEIQAACEIAABFImgDhLGSEFQAACEIAABCAAgfQRQJyljyUlQQACEIAABCAAgZQJIM5SRkgBEIAABCAAAQhAIH0EEGfpY0lJEIAABCAAAQhAIGUCGRFnd955p+26665WqVIle+ihh1KuZGQBW7Zssb59+1r9+vVtu+22s9deey1yt3v/zDPPuHO3atWq1D42QAACEIAABCAAgXwmkBFx1r9/f5s2bVpG2n3XXXc5QbZgwQK75557bP369aXOI3HWpEkT++CDD2zRokWl9rMBAhCAAAQgAAEI5CuBjIizTDZ23Lhx1rJlS9txxx2td+/e1rVr1xKnW716tc2fP99uuOEGt/2JJ54osZ8PEIAABCAAAQhAIJ8JBE6cLV261KpVqxaX6ZgxY+zUU0+1zp0727bbbmtPPvmkhUKhuPnZAQEIQAACEIAABPKJQFbF2W+//WbXX3+97bHHHlajRg07+OCDbfTo0WEeU6dOtaZNm9oOO+zghFWzZs1s0qRJbv/kyZNtn332sRUrVtioUaOcT1nNmjXDx/pvNKR5xhlnWK1atezEE0+0b775xlQuCQIQgAAEIAABCASBQFbF2cCBA23YsGE2fPhwJ7I6depkPXr0sJkzZzpW33//vXXv3t0JquXLl5vEV8+ePd2+9u3bO/+xevXq2fnnn++sYdH+Zt9++619/vnnduyxx7pjzjzzTPeXoU2Hgf8gAAEIQAACEAgAgayJs82bN9uDDz5op59+unXp0sX5jA0ePNgNUY4cOdKhkv/YkCFDbKeddrI6deq4oUn5kK1cuTIplLKadezY0apUqeLya2izevXq9vzzz9umTZuSKoNMEIAABCAAAQhAIJcEsibOZNHauHGjHXTQQeH2amhTITE08zJW8n3LNByaTPKHNP28tWvXdkObP/30k7388sv+Zv5CAAIQgAAEIACBvCWQNXG2YcMGB0HWMsU/81+LFy92ok07J0yYYMcdd5ztsssuzuJ1zTXXJA3uk08+sY8//tg0VOqXrb/jx493ZTC0mTRKMkIAAhCAAAQgkEMCWRNnElxK8jfT7MnIl+KRyV9MQ56ypE2fPt3WrVtnt99+e9Jonn76aTv77LNLlKtz/Pjjj27yweuvv27fffdd0uWREQIQgAAEIAABCOSCQNbEWaNGjdwMzLlz58Zsp6xeW7dutT59+tjee+/t8srylUySCHvuuefs0ksvLZVd/muaGKChUQ17kiAAAQhAAAIQgEA+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11xzjVviSv2qftbi7XLpUf9//fXXGawNRUOgbAJYzspmRI4sENCwgyKEn3322eGzBSHQ6ciRI03BQW+++eZwvXkTHAK+E78Cv77xxhv2448/Wp06dezwww+3q666Kq+Cv6br+3DDDTc4fziJEz+lq2y/vHz/G+mvprouXbo0HF+NYLj53nvFUT/EWXH0cyBbeeqpp7oZb9ms/KZNm6xdu3asGxkFXU7W/fv3N4kZRa9XatCggRviu/XWW+3YY4+NOiL2x9WrV7s1IHO18PXKlStNlieJsejgr+eff37eBH/VkKpie2ldSl/4i3GmQvlksuzoK2HLli325z//2a21qX1y3O/Tp49ddNFFzqIXnT8bnyPFWrxguFpYXou26yHy5JNPJgxKNjqmiM+BOCvizs+3pufD4scjRoywH374oUJo8qH+Fap4Egdp5qGWFko1SXBcccUV1qVLF+vRo4dbU1HBRzOVghb8VUJFw6bPPfec82e78sorM4Iml9fqiy++6CyUfsMUeFdWSlnPNYQsF4dkxb5fRjr/JgqGq3VlH3nkEYLhphM4ZcUkgM9ZTCxszDQBDaPccccdpqdRWVHkW3b11VeHTyshsMceezhfrn/84x/h7fL50XqDCllQu3Zt5zfz008/2X333ed8v7QY9MUXX+ysOvIFa9WqlU2fPj18vHxrFIVc59N++d1oYWkl3Qh1k/jyyy/deffZZ5/wcU8++aTzS9Ex8jPS4sw33XRTeL9mi02YMMEUW0lly6qk5WdIpQloEW/xVGgD9Ze4R/ZR6SOS3yKrx6xZs5zDtywcGqLUeZ555hln5dM1p2tA4qdfv37OUpYPUfllsVVgVcWX1NDq448/7iyVu+yyi2u81p5UO3S9Pvvss26b2qDhV/lLaSkorXsqES3Lr/w1/aTvmobfO3bs6FYh0KzSu+66y99tscrWtaty5Zum+oibytUyU/LN03dS9VGeM844w1577bVweXojP1G1pUWLFq6OJ510kv3rX/9y/aKylixZ4trSoUMHd5xCjqhO+k4pRpyEuyybOleukx8MV9eLmIv17bffbk2aNHF9Jg7yadNfbdf1V2zDxLnuo0I8P+KsEHs1AG3629/+ZgMGDLC//OUvpnhR3333nQ0cODBccwXsnDZtWviz3mhR5M6dO1vXrl3dDWPhwoW27777umERWWMuuOAC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\n",
      "text/plain": [
       "<PIL.PngImagePlugin.PngImageFile image mode=RGBA size=615x311>"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pathlib, subprocess\n",
    "pathlib.Path(\"cg.dot\").write_text(dot)\n",
    "subprocess.run([\"dot\", \"-Tpng\", \"cg.dot\", \"-o\", \"cg.png\"], check=True)\n",
    "\n",
    "from PIL import Image\n",
    "Image.open(\"cg.png\")"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [],
   "dockerImageVersionId": 31286,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 4.292416,
   "end_time": "2026-02-19T11:23:41.294370",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2026-02-19T11:23:37.001954",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
